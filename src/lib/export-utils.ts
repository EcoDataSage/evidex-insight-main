// Export utilities for Excel and JSON formats
import * as XLSX from 'xlsx';
import { MetricExtraction } from './ai-processor';
import { getMetricById } from './esrs-metrics';

export interface ESRSExportData {
  metadata: {
    reportDate: string;
    generatedBy: string;
    version: string;
    totalMetrics: number;
    extractedMetrics: number;
    completionRate: number;
  };
  metrics: Array<{
    id: string;
    category: string;
    label: string;
    value?: string;
    units?: string;
    confidence: number;
    confidenceLevel: string;
    isModelled: boolean;
    evidenceSource?: string;
    evidencePage?: number;
    evidenceText?: string;
    regulation: string;
    keywords: string[];
    explanation?: string;
    status: string;
  }>;
  summary: {
    environmental: { total: number; extracted: number; gaps: number };
    social: { total: number; extracted: number; gaps: number };
    governance: { total: number; extracted: number; gaps: number };
  };
}

// Helper function to determine confidence level
const getConfidenceLevel = (confidence: number): string => {
  if (confidence >= 0.8) return 'High';
  if (confidence >= 0.5) return 'Medium';
  if (confidence > 0) return 'Low';
  return 'No Data';
};

// Helper function to determine status
const getStatus = (extraction: MetricExtraction): string => {
  if (!extraction.value || extraction.confidence <= 0.3) return 'Gap';
  if (extraction.confidence >= 0.7) return 'Verified';
  if (extraction.isModelled) return 'Modelled';
  return 'Extracted';
};

// Export to Excel format
export const exportToExcel = async (extractions: MetricExtraction[]): Promise<Blob> => {
  const workbook = XLSX.utils.book_new();
  
  // Prepare summary data
  const categories = { Environmental: 0, Social: 0, Governance: 0 };
  const extracted = { Environmental: 0, Social: 0, Governance: 0 };
  const gaps = { Environmental: 0, Social: 0, Governance: 0 };

  // Main metrics data
  const metricsData = extractions.map(extraction => {
    const metric = getMetricById(extraction.metricId);
    if (!metric) return null;

    categories[metric.category]++;
    
    const hasValue = extraction.value && extraction.confidence > 0.3;
    if (hasValue) {
      extracted[metric.category]++;
    } else {
      gaps[metric.category]++;
    }

    return {
      'Metric ID': extraction.metricId,
      'Category': metric.category,
      'Subcategory': metric.subcategory,
      'Metric Name': metric.label,
      'Value': extraction.value || 'N/A',
      'Units': extraction.units || metric.unit || '',
      'Confidence Score': Math.round(extraction.confidence * 100) / 100,
      'Confidence Level': getConfidenceLevel(extraction.confidence),
      'Status': getStatus(extraction),
      'Is Modelled': extraction.isModelled ? 'Yes' : 'No',
      'Evidence Source': extraction.evidenceChunk?.source || 'N/A',
      'Evidence Page': extraction.evidenceChunk?.page || 'N/A',
      'Evidence Text': extraction.evidenceSpan || 'N/A',
      'Regulation': metric.regulation,
      'Priority': metric.priority,
      'Keywords': metric.keywords.join('; '),
      'Description': metric.description,
      'Explanation': extraction.explanation || 'N/A'
    };
  }).filter(Boolean);

  // Summary data
  const summaryData = [
    {
      'Category': 'Environmental',
      'Total Metrics': categories.Environmental,
      'Extracted': extracted.Environmental,
      'Gaps': gaps.Environmental,
      'Completion Rate': categories.Environmental > 0 ? Math.round((extracted.Environmental / categories.Environmental) * 100) + '%' : '0%'
    },
    {
      'Category': 'Social',
      'Total Metrics': categories.Social,
      'Extracted': extracted.Social,
      'Gaps': gaps.Social,
      'Completion Rate': categories.Social > 0 ? Math.round((extracted.Social / categories.Social) * 100) + '%' : '0%'
    },
    {
      'Category': 'Governance',
      'Total Metrics': categories.Governance,
      'Extracted': extracted.Governance,
      'Gaps': gaps.Governance,
      'Completion Rate': categories.Governance > 0 ? Math.round((extracted.Governance / categories.Governance) * 100) + '%' : '0%'
    },
    {
      'Category': 'TOTAL',
      'Total Metrics': extractions.length,
      'Extracted': extracted.Environmental + extracted.Social + extracted.Governance,
      'Gaps': gaps.Environmental + gaps.Social + gaps.Governance,
      'Completion Rate': extractions.length > 0 ? Math.round(((extracted.Environmental + extracted.Social + extracted.Governance) / extractions.length) * 100) + '%' : '0%'
    }
  ];

  // Metadata
  const metadataData = [
    { 'Field': 'Report Date', 'Value': new Date().toISOString().split('T')[0] },
    { 'Field': 'Generated By', 'Value': 'Evidexia AI' },
    { 'Field': 'Version', 'Value': '1.0' },
    { 'Field': 'Total Metrics Analyzed', 'Value': extractions.length },
    { 'Field': 'Successfully Extracted', 'Value': extracted.Environmental + extracted.Social + extracted.Governance },
    { 'Field': 'Data Gaps', 'Value': gaps.Environmental + gaps.Social + gaps.Governance },
    { 'Field': 'Overall Completion Rate', 'Value': extractions.length > 0 ? Math.round(((extracted.Environmental + extracted.Social + extracted.Governance) / extractions.length) * 100) + '%' : '0%' }
  ];

  // Create worksheets
  const metricsSheet = XLSX.utils.json_to_sheet(metricsData);
  const summarySheet = XLSX.utils.json_to_sheet(summaryData);
  const metadataSheet = XLSX.utils.json_to_sheet(metadataData);

  // Add sheets to workbook
  XLSX.utils.book_append_sheet(workbook, metricsSheet, 'ESRS Metrics');
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
  XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Metadata');

  // Apply some basic formatting
  const wscols = [
    { wch: 10 }, // Metric ID
    { wch: 15 }, // Category  
    { wch: 20 }, // Subcategory
    { wch: 40 }, // Metric Name
    { wch: 15 }, // Value
    { wch: 10 }, // Units
    { wch: 12 }, // Confidence Score
    { wch: 15 }, // Confidence Level
    { wch: 12 }, // Status
    { wch: 12 }, // Is Modelled
    { wch: 25 }, // Evidence Source
    { wch: 10 }, // Evidence Page
    { wch: 50 }, // Evidence Text
    { wch: 15 }, // Regulation
    { wch: 8 },  // Priority
    { wch: 30 }, // Keywords
    { wch: 50 }, // Description
    { wch: 30 }  // Explanation
  ];
  
  metricsSheet['!cols'] = wscols;

  // Generate Excel file
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
};

// Export to JSON format (structured for API consumption)
export const exportToJSON = (extractions: MetricExtraction[]): ESRSExportData => {
  const categories = { Environmental: 0, Social: 0, Governance: 0 };
  const extracted = { Environmental: 0, Social: 0, Governance: 0 };
  const gaps = { Environmental: 0, Social: 0, Governance: 0 };

  const metrics = extractions.map(extraction => {
    const metric = getMetricById(extraction.metricId);
    if (!metric) return null;

    categories[metric.category]++;
    
    const hasValue = extraction.value && extraction.confidence > 0.3;
    if (hasValue) {
      extracted[metric.category]++;
    } else {
      gaps[metric.category]++;
    }

    return {
      id: extraction.metricId,
      category: metric.category,
      label: metric.label,
      value: extraction.value,
      units: extraction.units || metric.unit,
      confidence: Math.round(extraction.confidence * 1000) / 1000, // 3 decimal places
      confidenceLevel: getConfidenceLevel(extraction.confidence),
      isModelled: extraction.isModelled,
      evidenceSource: extraction.evidenceChunk?.source,
      evidencePage: extraction.evidenceChunk?.page,
      evidenceText: extraction.evidenceSpan,
      regulation: metric.regulation,
      keywords: metric.keywords,
      explanation: extraction.explanation,
      status: getStatus(extraction)
    };
  }).filter(Boolean) as ESRSExportData['metrics'];

  const totalExtracted = extracted.Environmental + extracted.Social + extracted.Governance;
  const totalMetrics = extractions.length;

  return {
    metadata: {
      reportDate: new Date().toISOString(),
      generatedBy: 'Evidexia AI',
      version: '1.0',
      totalMetrics,
      extractedMetrics: totalExtracted,
      completionRate: totalMetrics > 0 ? Math.round((totalExtracted / totalMetrics) * 100) / 100 : 0
    },
    metrics,
    summary: {
      environmental: {
        total: categories.Environmental,
        extracted: extracted.Environmental,
        gaps: gaps.Environmental
      },
      social: {
        total: categories.Social,
        extracted: extracted.Social,
        gaps: gaps.Social
      },
      governance: {
        total: categories.Governance,
        extracted: extracted.Governance,
        gaps: gaps.Governance
      }
    }
  };
};